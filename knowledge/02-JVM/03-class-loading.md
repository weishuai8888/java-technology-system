# 虚拟机类加载机制

## 类生命周期的7个过程
加载（Loading）--> 验证（Verification）--> 准备（Preparation）--> 解析（Resolution）--> 初始化（Initialization）--> 使用（Using）--> 卸载（Unloading）,
其中验证、准备和解析三个部分统称为连接（Linking）。加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就
班的开始，而解析阶段则不一定：他在某些情况下可以在初始化阶段之后在开始，这是为了支持java语言的运行时绑定特性。

### 加载
有两种时机会触发类加载
- 预加载
    - 虚拟机启动时加载，加载的是JAVA_HOME/lib/下的rt.jar下的.class文件，像java.lang.-、java.util.-、java.io.-等等。
- 运行时加载 
  - 虚拟机在用到一个.class文件的时候，会先去内存中查看一下这个.class文件有没有被加载，如果没有就会按照类的全限定名来加载这个类。
- 加载阶段做了三件事
    - 获取.class文件的二进制流；
    - 将类信息、静态变量、字节码、常量这些.class文件中的内容放入方法区；
    - 在内存中生成一个代表这个 .class文件的java.lang.Class对象，作为方法区访问这个类的各种数据的入口。一般这个Class是在堆里，不过HopSpot虚拟机比较特殊，这个Class对象是放在方法区中的。
- 虚拟机获取.class文件的二进制流的来源
    - 从zip包中获取，即jar、ear、war格式文件；
    - 从网络中获取，典型应用就是Applet；
    - 运行时计算生成，典型应用就是动态代理技术；
    - 由其他文件生成，典型就是由jsp生成对应的.class文件；
    - 从数据库中读取，比较少见；
    - 从加密文件中获取。

### 验证
- 为什么要验证 
  - 因为我们的 .class文件可以通过多种方式产生，未必要从java源码编译而来。如果虚拟机不检查输入的字节流，对其完全信任的话，很可能会因为载入有害
的字节流而导致系统崩溃。所以验证是虚拟机对自身保护的一项重要的工作。
- 验证阶段的工作
  - 文件格式验证   
    - 元数据验证     
    - 字节码验证     
    - 符号引用验证

### 准备	
准备阶段时为类变量(被static修饰的变量)赋初值，而不是实例变量。实例变量会在对象实例化的时候随着对象一起分配在java堆中。赋初始值的变量是那些不被
final修饰的static变量。 
- 如private static int value = 128，value在准备阶段赋的值是0，而不是128，给value赋128是在初始化阶段进行的； 
- 如private static final int value = 128 就不一样了；在准备阶段，虚拟机就会给value赋值128。

### 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程；
- 符号引用和直接引用的区别
  - 符号引用是一种定义，可以是任何字面上的含义；
  - 直接引用是直接指向目标的指针、相对偏移量。直接引用和虚拟机是实现的内存布局有关，同一个符号引用在不同的虚拟机上翻译出来的直接引用一般不同。
如果有了直接引用，那引用的目标必定也已经存在内存中。
- 符号引用包含下面的三类常量
  - 类和接口的全限定名；
  - 方法的名称和描述符；
  - 字段的名称和描述符；
- 解析阶段的工作
  - 类和接口的解析；
  - 类方法解析；
  - 接口方法解析；
  - 字段解析；

### 初始化
1. 初始化的特点
   1. `<clinit>()` 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static()块）中的语句合并产生的，编译器收集的顺序是由语句在
原文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，而定义在它之后的变量，此静态语句块只能赋值，不可以访问； 
   2. java虚拟机会保证在子类的<clinit()>执行前，其父类的<clinit()>已经执行完毕。因此在java虚拟机中第一个被执行的`<clinit>()`方法肯定是
java.lang.Object； 
   3. 接口的实现类在初始化的时候不会执行接口的<clinit()>方法。因为只有父接口中定义的变量被使用时，父接口才会被初始化； 
   4. `<clinit>()`方法对于类和接口来说不会死必须的。如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法；
   5. java虚拟机必须保证一个类的<clinit()>方法在多线程中被正确的加锁同步。因为多线程同时去初始化一个类，只有其中一个线程去执行这个类的
<clinit()>方法，其他线程都需要阻塞等待，直到活动线程执行完毕此方法。
2. <clinit()>和<init()>方法的区别
    - <clinit()>执行时期是类的初始化阶段，只执行一次。该方法只能被JVM调用，专门承担类变量的初始化工作；
    - <init()>执行时期是在对象的初始化阶段，可以执行多次。

## 类加载器

### 类和类加载器的关系
比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载
他们的类加载器不同，那这两个类必定不相等。

### 三层类加载器
1. 启动类加载器（Bootstrap Class Loader） 
   - 负责加载存放在<JAVA_HOME>\lib目录或者被-Xbootclasspath参数所指定的路径中存放的，并且是java虚拟机能够识别的类库加载到虚拟机的内存中。
启动类加载器无法被java程序直接引用。用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，直接使用null替代即可；
2. 扩展类加载器（Extension Class Loader）
   - 负责加载<JAVA_HOME>\lib\ext目录或者被java.ext.dirs系统变量所指定的路径中所有的类库。这个类加载器是在类sun.misc.Launcher$ExtClassLoader
中以java代码的形式实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。
3. 应用程序类加载器（Application Class Loader）
   - 负责加载用户类路径（ClassPath）上所有的类库，开发者可以直接在代码中使用这个类加载器。由sun.misc.Launcher$AppClassLoader来实现。
如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

### 双亲委派模型工作过程
如果一个类加载器收到类加载请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给赋父类加载器去完成。因此所有的请求最终都会传到最顶层的启动类
加载器中，只有当父加载器反馈自己无法完成加载请求时，子类加载器才会尝试自己去完成加载。

### 为什么需要双亲委派模型
java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object，它存在于rt.jar中，无论哪一个类加载器要加载这个类，最终都
是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各类加载器环境中都能够保证时同一个类。反之，如果没有使用双亲委派模型，都由各个
类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object类，并放在程序的ClassPath中。那系统中就会出现多个不同的Object类，java
类型体系中最基础的行为也就无法保证，应用程序将会变得一片混乱。如果我们去编写一个rt.jar类库中已有类重名的java类，将会发现他可以正常编译，但永远
也无法被加载运行。

### 为什么要自定义类加载器
- 隔离加载类
  - 模块隔离，把类加载到不同的应用中。比如tomcat，内部自定义了好几种类加载器，用于隔离web应用服务器上的不同应用程序；
- 修改类加载方式
  - 除了Bootstrap加载器外，其他的加载并非一定要引入。根据实际情况按需进行动态加载；
- 扩展加载源
  - 比如还可以在数据库、网络、或其他终端上加载；
- 防止源码泄漏
  - 可以进行编译加密，类加载器需要自定义还原字节码；

### 什么时候破坏双亲委派模型
<font color="red">暂无答案</font>