### Java为什么要多一层JVM，而不是直接编译成机器语言？
- 进行自动内存管理；
- 针对不同系统定制化JVM，实现跨平台。

### 对象的创建过程
- 当java虚拟机遇到一条字节码new命令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、
解析和初始化过。如果没有，就必须先执行相应的类加载过程。
- 在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需的大小在类加载完成后便可完全确定。
- 内存分配完成后，虚拟机必须将分配到的内存空间（不包括对象头）都初始化为零值。这步操作保证了对象的实例字段在java代码中可以不被赋初值就直接使用，
使程序能够访问到这些字段的数据类型所对应的零值。
- 接下来，JVM还要对对象头进行必要的设置。例如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄信息、锁的设置等。
- 此时会接着执行`<init>()`方法，按照程序员的意愿对对象进行初始化。这样一个真正可用的对象才完全被构造出来。

### 分配对象内存的方式
1. 指针碰撞（Bump The Pointer）
如果堆内存中的对象是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着指针作为分界点的指示器，那所分配内存就仅仅是把那
个指针向空闲方向挪动一段与对象大小相等的距离。这种分配方式称为"指针碰撞"。
2. 空闲列表（Free List）
如果堆内存并不是规整的，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

### OOM
1. OOM常见原因
    - 内存中加载的数据过多，如一次从数据库中取出过多的数据；
    - 集合对象使用过多且使用后没有清空；
    - 代码中存在死循环或循环产生过多重复对象；
    - 堆内存分配不合理；